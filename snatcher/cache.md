# 数据存储之缓存模块

*缓存中保存了选课日志、登录信息等重要数据，所以它是这个系统不可缺少的一部分。*

---

缓存模块位于：`/snatcher/storage/cache.py` 下

这个模块下有这么几个函数或类：

- `publish_message`

  在消息频道中发布一条日志消息。

  每一条消息的格式都是像 `username-course_name|message_name|message` 这样的字符串。

  其中 `username-course_name` 是由学号和课程名构成日志键，`message_name` 是消息名称，`message` 表示消息详细内容。它们三者组成了一条完整的日志消息。

  它是一个异步装饰器，它只适合 `AsyncRuntimeLogger` 的特定方法，因此如果装饰到别的函数上面是会报错的。

- `parse_message`

  解析消息频道中的日志消息，返回一个字典类型。

  总的来说就是返回类似于像以下的字典：

  ```python
  {
      'username': '2204425143',
      'course_name': '现代礼仪',
      'name': 'xkkz_id',
      'msg': 'xkkz_id设置成功'
  }
  ```

- `AsyncRuntimeLogger`

  异步运行时日志记录器。一个日志键对应一个日志记录器。

  实际上使用了一个设计模式中的`代理模式`，底层实际上是对 `Redis` 的哈希数据类型的一系列操作。

  由于它使用了异步 `Redis` 操作，如果没有在操作完毕后关闭当前连接（不是连接池），那么代码将会引发异常。

  因此我将这个类设计成了一个异步上下文管理器，这样可以很好的控制资源的创建与释放。建议外部调用者也使用异步上下文管理器的方式使用它。

  例如：

  ```python
  import asyncio
  from snatcher.storage.cache import AsyncRuntimeLogger
  
  async def main():
      async with AsyncRuntimeLogger() as logger:
          await logger.update_logger_info('log-key')
          # 你的逻辑
          ...
          
  asyncio.run(main())
  ```

  其中有两个需要注意的方法：`set`、`retry`。这两个方法被调用时都将向日志频道中发布一条消息，因为它们都被`publish_message` 函数装饰了。

- `logging`

  记录课程选择器中的选课日志。

  在没有这个装饰器之前，课程选择器都是自己记录日志的。但是有了这个装饰器后，课程选择器可以在特定的方法上加上这个装饰器，这样进一步将课程选择器逻辑和日志逻辑**解耦**，从而达到**单一职责原则**的目的。

  这个特定的方法必须是：`set_kch_id`、`set_xkkz_id`、`set_jxb_ids`、`select_course`。

  装饰器内部会通过方法名来自动判断出日志的类型，因此这是一个非常方便的日志记录操作。

- `runtime_logs_generator`

  运行时日志生成器。生成缓存中的所有日志信息。

  生成的每一条日志格式将是：

  ```python
  {
      'course_name': '',
      'username': '',
      '1': '',  # 步骤 1
      '2': '',  # 步骤 2
      '3': '',  # 步骤 3
      '4': '',  # 步骤 4
      'retry': 'retry_times',
      'error': 'runtime error'
  }
  ```

  这个函数将会在后台管理系统中的日志监听中用到。

- `export_progress`

  导出一个抢课码对应的选课进度。

  在一个课程（一个日志键）对应的选课日志中，还额外存储了两个字段：`index`、`fuel_id`。

  `index` 表示当前课程的优先级，每一个用户可能会提交多个意向课程，`index` 的数值越小，选择这门课程的优先级越高。

  `fuel_id` 表示提交当前课程使用的 抢课码ID，因为用户查询选课进度需要用到抢课码进行查询。

  下面我来简单叙述一下这个函数的运行过程：

  1. 首先函数通过 抢课码ID 来过滤出这个抢课码对应的所有日志。

  2. 接着以日志中的 `index` 字段进行排序，从而得到正确的日志顺序。

  3. 此时我们已经得到了正确的日志序列。

  4. 由于每一个日志可能包含错误信息和重试信息，因此需要将这些信息进一步整理。

  5. 进入循环。

  6. 每一条日志会返回最后一次尝试的日志以及重试次数。

  7. 循环上述操作，直到清洗完所有日志。

  8. 返回一个字典类型，类似于以下：

     ```python
     user_log = {
         'username': '2204425143',
         'goals': ['中医药膳与食疗养生', '西方礼仪', '花卉赏析'],
         'progress': [[2, 3], [2, 3], [3, 1]]
     }
     ```

     `username` 表示学号。

     `goals` 表示该抢课码按照优先级排序好的所有课程。

     `progress` 列表的列表，子列表表示 [ 最后一次进度, 尝试次数 ]。比如 [ 2, 3 ] 表示的是 中医药膳与食疗养生 这门课程最后的进度是进度 2，尝试了 3 次。

整个缓存模块对日志的操作较多，但涉及到缓存的地方在其他模块也存在，后续也会提到。